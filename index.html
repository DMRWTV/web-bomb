<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web Bomb NFT - PSG1 Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            font-family: 'Courier New', Courier, monospace; 
        }
        canvas { 
            image-rendering: pixelated; 
            width: 100vw; 
            height: 100vh; 
            object-fit: contain; 
            background: #0a0a0a;
        }
        #ui { 
            position: absolute; 
            top: 30px; 
            left: 40px; 
            color: #00ffa3; 
            font-size: 32px; 
            text-shadow: 3px 3px #000; 
            pointer-events: none; 
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ui">BUTIN: <span id="score">0.000</span> SOL</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        // Dimensions HD PSG1
        const WIDTH = 1240;
        const HEIGHT = 1080;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        const GRID_X = 17;
        const GRID_Y = 13;
        const TILE = 80; // Taille des cases adaptée à la résolution
        const offsetX = (WIDTH - (GRID_X * TILE)) / 2;
        const offsetY = (HEIGHT - (GRID_Y * TILE)) / 2;

        let score = 0;
        let gameOver = false;
        let player = { x: 1, y: 1, lastMove: 0 };
        let bombs = [];
        let explosions = [];
        let enemies = [
            { x: 15, y: 11, dirX: -1, dirY: 0, lastMove: 0 },
            { x: 15, y: 1, dirX: 0, dirY: 1, lastMove: 0 },
            { x: 8, y: 6, dirX: 1, dirY: 0, lastMove: 0 }
        ];

        // --- SPRITES PIXEL ART (Matrices 10x10) ---
        const SPRITE_HERO = [
            [0,0,0,0,1,1,1,1,0,0],
            [0,0,1,1,2,2,1,1,1,0],
            [0,1,1,2,3,2,3,2,1,1], // Yeux
            [0,1,1,2,2,2,2,2,1,1],
            [0,0,1,1,1,1,1,1,1,0],
            [0,1,1,1,2,2,1,1,1,1], // Corps
            [0,1,2,2,2,2,2,2,2,1],
            [0,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,0,0,1,1,0,0],
            [0,1,1,1,0,0,1,1,1,0]
        ];

        const SPRITE_MONSTER = [
            [0,0,4,4,4,4,4,4,0,0],
            [0,4,4,4,4,4,4,4,4,0],
            [4,4,3,4,4,4,4,3,4,4], // Yeux méchants
            [4,4,3,4,4,4,4,3,4,4],
            [4,4,4,4,4,4,4,4,4,4],
            [4,4,0,4,4,4,4,0,4,4], // Bouche
            [4,4,4,0,0,0,0,4,4,4],
            [0,4,4,4,4,4,4,4,4,0],
            [0,4,0,4,0,0,4,0,4,0],
            [4,0,4,0,0,0,0,4,0,4]
        ];

        // Génération du labyrinthe
        const grid = [];
        for(let y=0; y<GRID_Y; y++) {
            grid[y] = [];
            for(let x=0; x<GRID_X; x++) {
                if(y===0 || y===GRID_Y-1 || x===0 || x===GRID_X-1 || (x%2===0 && y%2===0)) grid[y][x] = 1;
                else if(Math.random() > 0.4 && x > 2 && y > 1) grid[y][x] = 2;
                else grid[y][x] = 0;
            }
        }

        function drawPixelSprite(x, y, matrix, colors) {
            const p = TILE / 10;
            ctx.save();
            ctx.translate(x * TILE + offsetX, y * TILE + offsetY);
            matrix.forEach((row, r) => {
                row.forEach((type, c) => {
                    if(type > 0) {
                        ctx.fillStyle = colors[type];
                        ctx.fillRect(c*p, r*p, p, p);
                    }
                });
            });
            ctx.restore();
        }

        function explode(bomb) {
            bombs = bombs.filter(b => b !== bomb);
            const dirs = [{x:0,y:0}, {x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
            dirs.forEach(d => {
                let nx = bomb.x + d.x;
                let ny = bomb.y + d.y;
                if(grid[ny][nx] === 2) { 
                    grid[ny][nx] = 0; 
                    score += 10; 
                    scoreEl.innerText = (score/1000).toFixed(3); 
                }
                if(grid[ny][nx] !== 1) {
                    explosions.push({x:nx, y:ny, life: 15});
                    if(player.x === nx && player.y === ny) gameOver = true;
                    enemies.forEach(en => { if(en.x === nx && en.y === ny) en.dead = true; });
                }
            });
            enemies = enemies.filter(en => !en.dead);
        }

        function draw() {
            ctx.fillStyle = "#050505";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            if(gameOver) {
                ctx.fillStyle = "#ff4757";
                ctx.font = "bold 60px Courier New";
                ctx.textAlign = "center";
                ctx.fillText("GAME OVER", WIDTH/2, HEIGHT/2);
                ctx.font = "25px Courier New";
                ctx.fillText("APPUYEZ SUR START POUR RECOMMENCER", WIDTH/2, HEIGHT/2 + 60);
                return;
            }

            // Décors
            for(let y=0; y<GRID_Y; y++) {
                for(let x=0; x<GRID_X; x++) {
                    const gx = x * TILE + offsetX, gy = y * TILE + offsetY;
                    if(grid[y][x] === 1) { 
                        ctx.fillStyle = "#1a1a1a"; ctx.fillRect(gx, gy, TILE-2, TILE-2);
                        ctx.fillStyle = "#222"; ctx.fillRect(gx+10, gy+10, TILE-22, TILE-22);
                    } else if(grid[y][x] === 2) { 
                        ctx.fillStyle = "#4e342e"; ctx.fillRect(gx+4, gy+4, TILE-8, TILE-8); 
                        ctx.strokeStyle = "#3e2723"; ctx.strokeRect(gx+12, gy+12, TILE-24, TILE-24);
                    }
                }
            }

            // Explosions
            explosions = explosions.filter(e => {
                ctx.fillStyle = `rgba(255, ${150 + Math.random()*105}, 0, ${e.life/15})`;
                ctx.fillRect(e.x*TILE + offsetX, e.y*TILE + offsetY, TILE, TILE);
                return --e.life > 0;
            });

            // Bombes
            const blink = (Date.now() % 300 < 150);
            bombs.forEach(b => {
                ctx.fillStyle = blink ? "#ff4757" : "#000";
                ctx.beginPath();
                ctx.arc(b.x*TILE + TILE/2 + offsetX, b.y*TILE + TILE/2 + offsetY, TILE/3, 0, 7);
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.stroke();
            });

            // Joueur & Ennemis
            drawPixelSprite(player.x, player.y, SPRITE_HERO, {1: "#00ffa3", 2: "#fff", 3: "#000"});
            enemies.forEach(en => {
                drawPixelSprite(en.x, en.y, SPRITE_MONSTER, {4: "#ff4757", 3: "#fff", 0: "transparent"});
            });
        }

        function update() {
            const gp = navigator.getGamepads()[0];
            const now = Date.now();

            if(gameOver) {
                if(gp && gp.buttons[9].pressed) location.reload();
                return;
            }
            
            // IA Ennemis + Collisions Bombes
            enemies.forEach(en => {
                if(now - en.lastMove > 500) {
                    let nextX = en.x + en.dirX, nextY = en.y + en.dirY;
                    const isBomb = bombs.some(b => b.x === nextX && b.y === nextY);
                    if(grid[nextY][nextX] === 0 && !isBomb) {
                        en.x = nextX; en.y = nextY;
                    } else {
                        const moves = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                        const m = moves[Math.floor(Math.random()*4)];
                        en.dirX = m.x; en.dirY = m.y;
                    }
                    en.lastMove = now;
                    if(en.x === player.x && en.y === player.y) gameOver = true;
                }
            });

            // Mouvement Joueur + Collision Bombes
            if (gp && now - player.lastMove > 150) {
                let dx = 0, dy = 0;
                if (gp.buttons[12].pressed) dy = -1;
                else if (gp.buttons[13].pressed) dy = 1;
                else if (gp.buttons[14].pressed) dx = -1;
                else if (gp.buttons[15].pressed) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    let nx = player.x + dx, ny = player.y + dy;
                    const isBomb = bombs.some(b => b.x === nx && b.y === ny);
                    if (grid[ny][nx] === 0 && !isBomb) {
                        player.x = nx; player.y = ny;
                        player.lastMove = now;
                    }
                }
                if (gp.buttons[0].pressed) { // Bouton A
                    if(!bombs.some(b => b.x === player.x && b.y === player.y)) {
                        let b = {x: player.x, y: player.y};
                        bombs.push(b);
                        setTimeout(() => explode(b), 1500);
                    }
                }
            }
            draw();
            requestAnimationFrame(update);
        }
        update();
    </script>
</body>
</html>
